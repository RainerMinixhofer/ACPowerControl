#!/usr/bin/python3
# -*- coding:utf-8 -*-
#pylint: disable=C0103,E0401
"""
Test ramping AC voltage automatically from 1.5V up to 30V with the 1A Coil configuration
Test shorter ramp from 1.5V up to 15V with the 2A Coil configuration
"""
import time
import os
from math import sqrt
import pytest
from MCP23017 import MCP23017
import INA260 #pylint: disable=E0401

@pytest.fixture(name='mcp23017')
def fixture_mcp23017():
    """
    create chip driver with bank=0 mode on address 0x20, reset it to initialize
    via GPIO pin 4 of Raspi
    """
    #create chip driver with bank=0 mode on address 0x20
    portexpander = MCP23017(i2cbus=1, device=0x20, bank=0, resetpin=4)
    #Set all Pins of GPA and GPB of MCP23017 to output and disabled
    portexpander.all_to_output()
    #Check if the registers have been properly set
    assert portexpander.getregister("iodira") == 0x00, \
        "Direction of GPIOA registers not properly set. Is {}, and should be{}".\
            format(portexpander.getregister("iodira"), 0x00)
    assert portexpander.getregister("iodirb") == 0x00, \
        "Direction of GPIOB registers not properly set. Is {}, and should be{}".\
            format(portexpander.getregister("iodirb"), 0x00)
    yield portexpander

    del portexpander

@pytest.fixture(name="ina260")
def fixture_ina260():
    """
    Initialize I2C Bus #1 for INA260 with address 0x40
    Set Averaging mode for 512 averages at 1.1ms conversion time
    in continous mode measuring Shunt Current and Bus Voltage
    """

    #INA260 Power Meter has address 0x20 on I2C Bus #1
    #we take a long conversion time of 1.1ms together with the highest
    #number of averaging samples in continous mode, which should yield sufficient accuracy
    #to get a good estimate for the AC effective voltage
    #Measuring only Bus Voltage. Voltage divider resistor is 220kOhm
    #These settings are read in from the JSON file ina260.json (if existing) which has been
    #generated by the calibration script VoltageCalibration.py
    if os.path.isfile('ina260.json'):
        print("Reading Configuration file ina260.json")
        meter = INA260.INA260Controller(config='Automatic')
    else:
        meter = INA260.INA260Controller(alertpin=13, avg=1024, vbusct=1100, ishct=140, \
                                         meascont=True, measi=False, measv=True, Rdiv1=220, \
                                         Rvbus=211.8, Vt=0.1582257, \
                                         config='Automatic', writeconfig=True)
    yield meter

    del meter

@pytest.fixture(name='MCP23017Regs1A')
def fixture_MCP23017Regs1A():
    """
    #Define voltage ladder one gets from the valid combination of the 3V, and 2x6V
    #secondary coils of the transformer for low current (1A) option
    """

    validV1A = []
    for i in range(10):
        validV1A.append(1.5 * (i+1))
    for i in range(5):
        validV1A.append(3.0 * (i+1) + validV1A[9])

    #Define the corresponding register settings for the required connections
    #for the above defined voltage ladder. The MSB byte is port A the LSB byte is port B
    reg1A = [0x0C06, 0x0C00, 0x1406, 0x1080, 0x2406, 0x1400, 0x9206, 0x2080, 0x6106, \
             0x2400, 0x8900, 0x9200, 0x6200, 0x6100, 0xA100]
    dict1A = dict(zip(validV1A, reg1A))

    yield dict1A
    del dict1A

@pytest.fixture(name='MCP23017Regs2A')
def fixture_MCP23017Regs2A():
    """
    #Define voltage ladder one gets from the valid combination of the 3V, and 2x6V
    #secondary coils of the transformer for the high current (2A) option
    """

    validV2A = []
    for i in range(6):
        validV2A.append(1.5 * (i+1))
    for i in range(2):
        validV2A.append(3.0 * (i+1) + validV2A[5])

    #Define the corresponding register settings for the required connections
    #for the above defined voltage ladder. The MSB byte is port A the LSB byte is port B
    reg2A = [0x094E, 0x0948, 0x1156, 0x1218, 0x2166, 0x1150, 0x2228, 0x2160]
    dict2A = dict(zip(validV2A, reg2A))
    yield dict2A
    del dict2A

def voltage2registers(voltage, vdict):
    """
    Converts the specified ac voltage in the tuple <allowed Vac>, <register a> and
    <register b> using the specified dictionary for high or low current
    configuration and returns the values.
    """
    #Limit voltage to allowed values. Take closest allowed value from validVxA lists
    voltage = min(list(vdict.keys()), key=lambda x: abs(x-voltage))
    regs = vdict[voltage]
    return voltage, regs >> 8, regs & 0xFF

def switchsequence(portextender, powermeter, Vac, vdict):
    """

    Parameters
    ----------
    highcurrent : Boolean
        If True the register settings for 2A configuration is returned, if
        False then the register setting for 1A is returned
    portextender, powermeter : object
        Objects for the handling of the portextender and the powermeter respectively
    Vac : Integer
        Specifies AC Voltage given by the definition of gpa and gpb ports.
    vdict : Dictionary
        Specifies a dictionary of the register settings needed for a given voltage.

    Returns
    -------
    None

    """

    #Get the required register settings for specified voltage Vac
    Vac, gpa, gpb = voltage2registers(Vac, vdict)
    #Set relais positions for required voltage and leave mains pin off
    #Then switch on mains
    portextender.setregister("gpioa", gpa)
    portextender.setregister("gpiob", gpb)
    portextender.enable('Mains')
    time.sleep(1.0)
    #Readout on voltmeter, wait 1s to get voltage settled and to enable measurement integration
    #Since we have a single rectifier in the sensing circuit
    #The AC effective voltage measured is sqrt(2) times lower than the
    #effective voltage
    effvoltage = 0
    count = 0
    while abs(effvoltage-Vac)>1.0 and (count<1): #pylint: disable=R1716
        print("Measuring....")
        powermeter.alert = ['Conversion Ready']
        assert powermeter.wait_for_alert_edge(timeout='Automatic'), \
        print("Timeout of conversion ready detection")
        effvoltage = powermeter.voltage() * sqrt(2)
        print("Voltage setting: {:4.1f}V ({:5.2f}V measured)".format(Vac, effvoltage))
        count += 1
    #Wait for voltage peak to minimize EMC when switching off mains
    powermeter.wait_for_voltage_peak()
    #Switch mains off
    portextender.disable('Mains')
    time.sleep(1.0)
    portextender.setregister("gpioa", 0x00)
    portextender.setregister("gpiob", 0x00)
    time.sleep(1.0)
#    portextender.reset()
#    portextender.all_to_output()

def test_VoltageRamp_1A(mcp23017, ina260, MCP23017Regs1A):
    """
    Test Voltage Ramp from 1.5V up to 30V in 1A coil configuration
    """
    print("Ramping Voltage from 1.5V up to 30V in 1A coil configuration")
    time.sleep(1.0)
    for vac in list(MCP23017Regs1A.keys()):
        switchsequence(mcp23017, ina260, vac, MCP23017Regs1A)

    print("End of 1A Coil Voltage Ramp")

def test_VoltageRamp_2A(mcp23017, ina260, MCP23017Regs2A):
    """
    Test Voltage Ramp from 1.5V up to 30V in 1A coil configuration
    """
    print("Ramping Voltage from 1.5V up to 15V in 2A coil configuration")
    time.sleep(1.0)
    for vac in list(MCP23017Regs2A.keys()):
        switchsequence(mcp23017, ina260, vac, MCP23017Regs2A)

    print("End of 2A Coil Voltage Ramp")
